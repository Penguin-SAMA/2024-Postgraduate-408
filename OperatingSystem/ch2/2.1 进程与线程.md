# 2.1 进程与线程

## 2.1.1 进程的概念和特征

#### 进程的概念

进程是计算机中一个执行的程序实例，是操作系统资源分配和调度的独立单位，是操作系统中最基础与最重要的概念之一。

进程控制块PCB：操作系统为每个进程配备的一个记录型数据结构。

由**程序段**、**数据段**和**PCB**三部分构成了进程实体(也称进程映像)。

所谓创建进程，实质上是创建进程实体中的PCB；

而撤销进程，实质上是撤销进程的PCB。

==❗注意：PCB是进程存在的唯一标志！！！==

> 进程的定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

#### 进程的特征

- 动态性：动态性是进程最基本的特征。
- 并发性。
- 独立性：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。
- 异步性。

#### 进程的其他定义

- 进程是程序的一次执行过程。
- 进程是一个程序及其数据在处理器上顺序执行时所发生的活动。
- 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的独立单位。
- 进程是正在计算机上执行的程序实例。
- 进程是能分配给处理器并由处理器执行的实体。
- 进程是由一组执行的指令、一个当前状态和一组相关的系统资源表征的活动单元。
- 进程由程序段、数据段、进程控制块三部分组成。

## 2.1.2 进程的状态与转换

进程通常有以下五种状态：

- 运行态：进程在处理机上运行。
- 就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。
- 阻塞态(也称等待态)：进程正在等待某一事件而暂停运行，如等待某资源为可用或等待输入/输出完成。
- 创建态(也称新建态)：进程正在被创建，尚未转到就绪态。
- 终止态(也称结束态)：进程正从系统中消失，可能是进程正常结束或其他原因退出运行。

<img src="./assets/f0e1d9a8944841502eb342f1990827c.jpg" alt="f0e1d9a8944841502eb342f1990827c" style="zoom: 33%;" />

> 区别就绪态和等待态：
>
> - 就绪态是指进程仅缺少处理器，只要获得处理机资源就立即运行。
> - 等待态是指进程需要其他资源或等待某一事件。

三种基本状态的转换：

- 就绪态->运行态：处于就绪态的进程被调度后，获得处理机资源，于是进程由就绪态转换为运行态。
- 运行态->就绪态：处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。
- 运行态->阻塞态：进程请求某一资源的使用和分配或等待某一事件的发生时，它就从运行态转换为就绪态。
- 阻塞态->就绪态：进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把进程由阻塞态转换为就绪态。
- <img src="./assets/image-20230320213843363.png" alt="image-20230320213843363" style="zoom: 67%;" />

> - 不能由阻塞态直接转换为运行态。
> - 不能由就绪态直接转换为阻塞态。
> - 一个进程从运行态变成阻塞态是主动行为。
> - 一个进程由阻塞态变成就绪态是被动行为。

## 2.1.3 进程组织

进程是操作系统资源分配的最小单位，在未引入线程概念的操作系统中，也是调度的最小单位。

#### 进程控制块PCB的功能概述

- 作为独立运行基本单位的标志。
- 实现进程的间断运行。
- 提供进程调度和管理所需要的信息。
- 实现与其他进程的同步与通信。

#### PCB中的内容

- 标识符：标识符是唯一标识，以数字或数字加字母的形式存储在PCB中。
  - 进程标识符PID
  - 父进程的PID
  - 用户标识符UID
- 处理器状态信息：又称处理器上下文，记录进程在执行态下关键寄存器的信息，用于进程切换后恢复处理器上的重要信息。
  - 通用寄存器
  - 程序计数器PC
  - 程序状态字PSW
  - 用户栈指针
- 处理器调度信息：该类信息的存储取决于操作系统使用何种调度方法来将处理器分配给进程。
  - 进程调度状态，记录执行态、就绪态、阻塞态等。
  - 进程调度优先级，在多个进程就绪时，用于决定那个进程先获得处理器资源。
  - 调度的相关信息，这取决于调度算法。
  - 事件，指进程由执行态转换为阻塞态的原因。
- 进程控制信息：用于进程控制所必须的信息。
  - 代码段和数据段的地址
  - 进程同步和通信机制
  - 进程特权
  - 资源清单
  - 存储管理
  - 链接指针

## 2.1.4 进程控制

进程控制包括创建新进程、撤销已有进程、实现进程状态转换等功能。

一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

原语采用“关中断指令”和“开中断指令”实现。

> 两个问题：
>
> - 为什么需要把多个指令设计成一个原语？
>
>   如果多个指令不是一个原语，两个进程可能会发生冲突，互相都认为自己可以使用设备，发生错误。
>
> - 为什么在进程控制的过程中要使用原语？
>
>   进程创建、进程唤醒等一系列控制操作均包含了多个步骤，要确保这些步骤全部进行或全部不进行才能得到正确的结果。

### 进程的创建

#### 进程创建的场合

- 用户登陆时。
- 高级调度发生时。
- 系统响应用户程序提出的请求时。
- 现有进程创建新进程时。

#### 进程创建原语的执行过程

- 为进程分配一个唯一的进程标识号，并申请一个空白PCB。
- 为进程分配其运行所需的资源。==如果资源不足，并不是创建失败，而是处于创建态，等待内存资源==。
- 初始化PCB。
- 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。

### 进程的终止

#### 进程终止的场合

- 进程运行完毕，正常退出。
- 进程运行中出现错误退出，例如除零异常。
  - ==当发生了这种错误后，进程会收到操作系统反馈的信号，而不至于错误发生时就立刻退出==。
- 进程发生了严重错误而退出。
- 被其他进程杀死。
- 其他：例如超过时限、无可用内存、访问越界、保护错误、I/O失败、无效指令、数据误用等。

#### 终止原语的执行过程

- 根据进程的PID，找到进程对应的PCB，获取进程的状态。
- 修改该进程的状态，置位终止态。
- 若该进程运行期间调用了进程创建指令，创建了子进程，则要把其子进程也进行终止。
- 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。
- 将该PCB从所在队列(链表)中删除。

### 进程的阻塞和唤醒

> - 当进程请求资源失败或等待某个事件发生时，该进程无法继续执行，便会执行阻塞原语，让出处理器资源，变为阻塞态。
> - 当进程请求的资源到达或等待的事件发生时，相关进程可以调用唤醒原语，通知之前因为等待而变为阻塞态的进程，使其变为就绪态。

⚠️注：

- 进程阻塞的过程是主动的，而进程唤醒的过程是被动的。
- 阻塞原语和唤醒原语一定是成对出现的。

#### 进程阻塞的场合

- 进程向系统请求临界资源失败。
- 进程等待某种操作的完成。
- 新数据尚未到达。
- 等待新任务的到达。

#### 阻塞原语的执行过程

- 根据进程的PID，找到进程对应的PCB，获取进程的状态。
- 若该进程当前为执行态，将状态转换为阻塞态，将其PCB插入到阻塞队列中。
- 进行上下文切换，从就绪队列中选择一个进程，将其转换为运行态并为其分配处理器，使其可以运行。

#### 进程唤醒的场合

- 进程向系统请求临界资源失败后，使用该临界资源的进程释放了该资源。
- 进程等待的操作已经发生。
- 进程等待的数据到达。
- 进程获得了一个新的任务。

#### 唤醒原语的执行过程

- 找到阻塞队列中对应进程的PCB。
- 更改该进程状态为就绪态，将该进程的PCB放入就绪队列中。

### 进程切换

进程切换，指操作系统内核挂起当前运行的进程，调度就绪进程占用处理器运行。

> 进程切换必然发生在内核态而不是用户态。

#### 上下文切换

- 上下文切换，指保存和恢复处理器上的信息，也可认为是==保存当前使用处理器进程的相关信息，并将待调度进程的处理器信息恢复到处理器上。

- “上下文”可理解为进程的工作环境。

#### 上下文切换的时机

- 上下文切换发生在操作系统从执行态进程处获得控制权的任意时刻。
- 中断、陷阱、系统调用，这些事件都会导致控制权移交给操作系统。

#### 上下文切换过程

- 保存处理器的上下文。
- 修改进程状态。
- 调度程序选择另一个进程执行。
- 读取待调度进程的PCB，修改其运行状态为执行态。
- 更新内存管理的数据结构。
- 恢复待调度程序的上下文环境。
- 根据程序计数器(PC)指向的位置找到下一行执行的代码，恢复该进程。

## 2.1.5 进程的通信

进程通信是指进程之间的信息交换。

实现进程通信需要解决三个问题：

-   进程通过何种方式把信息传递给其他进程。
-   保证多个进程在关键活动上不会重叠。
-   进程按照正确的顺序推进。

==⚠️一个进程不能直接访问另一个进程的地址空间==

### 共享存储

在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。

在对共享空间进行读/写操作时，需要使用**同步互斥工具**，对共享空间的读/写进行控制。

共享存储分为两种：

- 低级方式的共享是基于数据结构的共享。
- 高级方式的共享是基于存储区的共享。

<img src="./assets/IMG_1133.JPG" alt="IMG_1133" style="zoom:33%;" />

### 消息传递

在消息传递系统，进程间的数据交换以格式化的信息为单位。

**格式化的信息**：消息头 + 消息尾

进程通过系统提供的发送消息(send)和接收消息(receive)两个原语进行数据交换。

- **直接通信方式**：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
- **间接通信方式**：发送进程把消息发送到某个中间实体(一般称为“信箱”)，接收进程从中间实体取得消息。

>   间接通信方式和共享存储区通信方式有相似之处，区别在于间接通信方式由操作系统规范化管理，不允许进程直接操作开辟的空间，因此比共享存储更加安全，但效率略有下降。

<img src="./assets/IMG_1134.JPG" alt="IMG_1134" style="zoom: 25%;" />

### 管道通信

管道通信允许两个进程按生产者-消费者方式进行通信，生产者向管道的一端写，消费者从管道的另一端读。

数据在管道中是**先进先出**的。

管道机制必须提供三方面的协调能力：**互斥**、**同步**和**确定对方的存在**。

- 管道只能采用**半双工通信**。如果要实现双向同时通信，需要设置两个管道。

- 当有一个进程在对一个管道进行读/写时，其他想要读/写该管道的进程必须等待。

- 当管道写满时，写进程将阻塞；当管道读空时，读进程将堵塞。

- 管道是一个固定大小的缓冲区，在内核中实现，大小不受磁盘大小影响。

- 管道的实质是一个共享文件，读进程将管道视为输出文件，写进程将管道视为输入文件，利用文件系统机制实现。

- 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。

  两种解决方案：

  - 一个管道允许多个写进程，一个读进程。
  - 允许多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据。

<img src="./assets/IMG_1135.JPG" alt="IMG_1135" style="zoom:25%;" />

## 2.1.6 线程和多线程模型

线程最直接的理解就是“轻量级线程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。

>   在引入线程前，进程是操作系统调度的最小单位；
>   在引入线程且是由操作系统内核支持的线程之后，线程是操作系统调度的最小单位。
>   同时，进程仍然是操作系统分配资源的最小单位，线程的引入并未改变进程资源所有权这一特点。

### 引入线程的优势

#### 进一步提高并发性能

借助多线程，可以分解部分被阻塞的活动，使得一个进程的任务能进一步细分，提高任务的并行性。

#### 共享地址空间与可用数据

线程使得并行实体拥有了共享地址空间、数据的能力，这种能力是一些任务需要但进程模型无法提供的。

#### 线程更轻量级

线程无论是撤销还是创建，都远快于进程。
在短时间需要反复开启或撤销大量线程时，线程的轻量级是十分有优势的。

#### 性能上的优势

如果开启的多个线程均为处理器密集型，则线程难以提升进程执行的效率。
而当一个进程同时存在着大量的I/O请求和计算时，通过线程可以让这些活动彼此重叠，从而大大加快进程的执行速度。

>   处理器密集型：一个线程或进程主要的工作是使用处理器进行计算，很少用到I/O设备。
>   I/O密集型：一个进程或线程使用I/O设备远多于处理器。

### 线程的属性

-   线程是处理机调度的单位
-   多CPU计算机中，各个线程可占用不同的CPU
-   每个线程都有一个线程ID、线程控制块TCB
-   线程也有就绪、阻塞、运行三种基本状态
-   线程几乎不拥有系统资源
-   同一进程的不同线程间共享进程的资源
-   由于共享内存空间，同一进程中的线程间通信甚至无需系统干预
-   统一进程中的线程切换，不会引起进程切换，系统开销很小
-   不同进程中的线程切换，会引起进程切换，系统开销较大

### 线程的组织

一个操作系统中的多个进程之间具有很大的独立性，而进程中的多个线程则不同，它们拥有完全相同的地址空间，这意味着它们可以共享全局数据。

<img src="./assets/IMG_1129-1680236254095-2.jpg" alt="IMG_1129" style="zoom: 25%;" />

#### 线程的三个基本状态

-   执行态：在该状态下，线程获得处理器并运行
-   就绪态：表示线程可以被调度进行，被分配处理器就可以立刻执行工作
-   阻塞态：指线程在执行过程中，因为某些事件而阻塞并等待

#### 线程控制块TCB

每个线程也具有一个对应的线程控制块TCB，用于控制和管理线程的状态、保存线程的信息。

线程控制块中通常有以下几类信息：

-   线程标识符TID：每个线程的唯一标识符。
-   寄存器信息：用来记录包括通用寄存器、程序计数器、状态寄存器等关键寄存器的信息。
-   线程执行态：用于记录线程的执行状态。
-   优先级：用于线程调度。
-   线程专有存储区：用于线程切换时保存现场信息。
-   信号屏蔽：每个线程拥有各自的信号屏蔽字。
-   堆栈指针：TCB中分别设置了两个指向堆栈的指针，分别指向自己的堆栈和核心栈。

>   核心栈是线程运行在内核态时使用的。

### 线程的实现方式

#### 用户级线程ULT

-   线程的管理由应用程序实现，在用户空间下完成。

-   操作系统内核感知不到线程的存在，在该种方式下，调度的最小单位依然是进程，线程的调度则由其所在进程实现。

-   优点：

    -   线程切换不需要转换到内核空间，节省了模式切换的开销。
    -   调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。
    -   用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。
    -   可以在不支持线程的操作系统中实现线程。
    -   可以允许进程自主定制调度算法。
    -   线程的切换完全在本进程中完成而没有内核的参与。

    >   所有线程相关的数据结构都在进程的用户地址空间，所以线程的切换不需要转换成内核态，这就避免了两次状态转换带来的开销。

-   缺点：

    -   一旦某个线程被阻塞，该线程所属的整个进程都会被阻塞。
    -   如果只使用用户级线程，一个多线程程序不能利用多处理器技术。

#### 内核级线程

-   内核级线程在内核的支持下运行，线程管理的所有工作也是在内核空间内实现的。
-   内核通过TCB来对线程进行感知和控制。
-   在该种方式下，线程是调度的最小单位。
-   优点：
    -   在多处理系统中，内核可以调度一个进程内的多个线程到多个处理器上运行。
    -   当一个线程被阻塞，内核可以调度该进程中的另一个线程到处理器上运行。
    -   内核进程自身可以使用多线程。
-   缺点：
    -   同一进程中的线程切换，需要从用户态转到和核心态进行，系统开销较大。

#### 组合方式

在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。

**线程库**是为程序员提供创建和管理线程的API。实现线程库的两种方法：

-   在用户空间中提供一个没有内核支持的库。
-   实现由操作系统直接支持的内核级的一个库。

<img src="./assets/IMG_1132.JPG" alt="IMG_1132" style="zoom:30%;" />

#### 多线程模型

由于用户级线程和内核级线程连接方式的不同，从而形成了下面三种不同的多线程模型：

-   **多对一模型**：将多个用户级线程映射到一个内核级线程。
    -   优点：线程管理是在用户空间进行的，效率比较高。
    -   缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。
-   **一对一模型**：将每个用户级线程映射到一个内核级线程。
    -   优点：当一个线程被阻塞后，允许调度另一个线程运行，并发能力较强。
    -   缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。
-   **多对多模型**：将n个用户线程映射到m个内核级线程上，要求$n\geq m$。
    -   特点：克服了多对一模型并发度不高的缺点；克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。

<img src="./assets/IMG_1131.JPG" alt="IMG_1131" style="zoom: 20%;" />

#### 进程和线程的对比

|          |            进程            |              线程              |
| :------: | :------------------------: | :----------------------------: |
|   调度   |    不再是调度的最小单位    |        是调度的最小单位        |
| 拥有资源 | 进程都是资源分配的基本单位 |       线程只拥有少量资源       |
|  并发性  |   多个进程间可以并发执行   | 一个进程的多个线程也能并发执行 |
|  独立性  |       只共享全局变量       |      只有少数资源不能共享      |
| 系统开销 |    通信、进程切换开销大    |        通信、切换开销小        |
|   其他   |      进程间相互不影响      | 用户级线程的阻塞会影响整个进程 |

